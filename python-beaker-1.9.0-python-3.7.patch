diff -up beaker-1.9.0/beaker/synchronization.py.omv~ beaker-1.9.0/beaker/synchronization.py
--- beaker-1.9.0/beaker/synchronization.py.omv~	2018-03-29 15:29:38.624040636 +0200
+++ beaker-1.9.0/beaker/synchronization.py	2018-03-29 15:30:03.845121140 +0200
@@ -286,7 +286,7 @@ class ConditionSynchronizer(Synchronizer
         super(ConditionSynchronizer, self).__init__()
 
         # counts how many asynchronous methods are executing
-        self.async = 0
+        self.asynch = 0
 
         # pointer to thread that is the current sync operation
         self.current_sync_operation = None
@@ -307,7 +307,7 @@ class ConditionSynchronizer(Synchronizer
                 if self.current_sync_operation is not None:
                     return False
 
-            self.async += 1
+            self.asynch += 1
         finally:
             self.condition.release()
 
@@ -317,16 +317,16 @@ class ConditionSynchronizer(Synchronizer
     def do_release_read_lock(self):
         self.condition.acquire()
         try:
-            self.async -= 1
+            self.asynch -= 1
 
             # check if we are the last asynchronous reader thread
             # out the door.
-            if self.async == 0:
+            if self.asynch == 0:
                 # yes. so if a sync operation is waiting, notifyAll to wake
                 # it up
                 if self.current_sync_operation is not None:
                     self.condition.notifyAll()
-            elif self.async < 0:
+            elif self.asynch < 0:
                 raise LockError("Synchronizer error - too many "
                                 "release_read_locks called")
         finally:
@@ -354,7 +354,7 @@ class ConditionSynchronizer(Synchronizer
             self.current_sync_operation = _threading.currentThread()
 
             # now wait again for asyncs to finish
-            if self.async > 0:
+            if self.asynch > 0:
                 if wait:
                     # wait
                     self.condition.wait()
